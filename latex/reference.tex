\chapter{Reference}
\label{reference}

\section{The BMotion Studio API}
\label{sec:bmsapi}

(tbd)

\section{Observers}
\label{sec:observers}

Observers are used to link visual elements with the model. 
An observer is notified whenever a model has changed its state, i.e. whenever an event has been executed. 
In response, the observer will query the model's state and triggers actions on the linked visual elements in respect to the new state. 

\subsection{Observers in Groovy}
\label{sec:groovy_observers}

In general, observers are defined in the Groovy script file.
\bms~comes with some predefined observers that are described in the following sections.

\subsubsection{Transformer Observer}
\label{sec:transformer_observer}

The transformer observer supports the modification of attributes of visual elements based on the current state of the animation.
The following code snippet demonstrates the basic use of the transformer observer:

\begin{lstlisting}[float=ht,language=Groovy]
transform("#myvisualelement") {
    set "fill", "green"
    set "stroke", "red"
    register(bms)
}
\end{lstlisting}

In line 1 we define a jQuery selector to select the visual elements which should be transformed.
In this case we select a visual element with the id \textit{myvisualelement} (in jQuery the prefix ``\#'' denotes that we want to select and element by its id).
jQuery provides several possibilities to select visual elements.

\info{The jQuery selector API documentation\footnote{\url{http://api.jquery.com/category/selectors/}} provides an overview and a detailed documentation about selectors.}

Line 2 to 3 are actions that are made on the visual elements which are matched by the defined selector.
In this case the \textit{fill} attribute is set to the value \textit{green} and the \textit{stroke} attribute to \textit{red}.
In line 4, we register the observer to the current visualisation.
A registered observer is triggered after every state change, e.g. after executing an event.

\paragraph{Groovy Closures.}
%As we use the Groovy Scripting language for defining the observers, we can make use of the entire function and feature range of it.
Transformer observers support the use of Groovy closures for defining the selector or the value of an action.
The following code snippet demonstrates the use of closures for transformer observers:

\begin{lstlisting}[float=ht,language=Groovy]
transform("#myvisualelement") {
  set "fill", { (bms.eval("1 < x").value == "TRUE") ? "white" : "lightgray" }
  set "y", {
    switch (bms.eval("x").value) {
      case "0": "15"
        break
      case "1": "20"
        break
      case "2": "25"
        break
      default: "0"
    }
  }
  register(bms)
}
\end{lstlisting}

In Groovy a closure is encapsulated in curly brackets.
Line 2 and 3 show two examples for using closures for defining the value of the attribute \textit{fill} and \textit{y} respectively.
Closures are evaluated after every state change in consequence of triggering the transformer observer.
As an example, in line 2 the closure evaluates the expression $1 < x$.
The value of the \textit{fill} attribute is set to \textit{white} whenever the expression evaluates to \textit{TRUE} and otherwise to \textit{lightgray}.


\subsubsection{Method Observer}
\label{sec:method_observer}

The following code snippet gives an example of the method observer:

\begin{lstlisting}[float=ht,language=Groovy]
callMethod("mymethod") {
  data([foo: "bar"])
  register(bms)
}
\end{lstlisting}

\subsubsection{Custom Observer}
\label{sec:custom_observers}

The following code snippet gives an example of a custom observer:
\begin{lstlisting}[float=ht,language=Groovy]
def customObserver = [ 
  apply: { bms ->  println "Triggering custom observer." } 
] as BMotionObserver
bms.registerObserver(customObserver)
\end{lstlisting}

You can also create a custom transformer observer:
\begin{lstlisting}[float=ht,language=Groovy]
def transformerObserver = [
  update: { bms ->
    def transformers = []
    def result = bms.translate("relation")					
    result.value.each { obj ->
      transformers += transform("#" + obj.first) {
        set "transform", "translate(" + obj.second + ")"
        update(bms)
      }
    }
    return transformers
  }
] as BMotionTransformer
bms.registerObserver(transformerObserver)
\end{lstlisting}

\subsection{Observers in JavaScript}
\label{sec:js_observers}

The user can also create an observer in JavaScript.
The following sections explain the observers and their options.
In general, an observer is assigned to a jQuery selector.

\subsubsection{Formula Observer}

The formula observer observes a list of formulas (i.e. expressions or predicates) and triggers a function whenever a state change occurred.
The result of the formulas are passed to the trigger function.
The following options can be passed:

\begin{tabular}{ l l l p{7cm} }
  \textbf{Name} & \textbf{Type} & \textbf{Default} & \textbf{Description} \\
  \hline\noalign{\medskip}
  formulas & list / function* & empty list & Define a list of expressions that should be evaluated and passed to the trigger function. Example: $['x < 4', 'card(x)']$.\\
  \hline\noalign{\medskip}
  cause & string / function* & '\textit{AnimationChanged}' & The trigger cause. Possible values: '\textit{AnimationChanged}', '\textit{ModelChanged}' and '\textit{ModelInitialised}'. \\
  \hline\noalign{\medskip}
  trigger & function &  & The trigger function will be called after every state change with its \textit{origin} reference set to the element that the observer is attached to and the requested \textit{data} (the result of the expressions). \\
\end{tabular}

*This attribute also accepts a function that should return its value.

\begin{lstlisting}[float=ht,language=JavaScript]
$("#door").observe("formula", {
  formulas: ["cur_floor", "door_open"],
  trigger: function (origin, data) {
    var values = data.values
    switch (values[0].value) {
      case "-1": origin.attr("y", "275"); break
      case "0": origin.attr("y", "175"); break
      case "1": origin.attr("y", "60"); break
    }
    values[1].value === "TRUE" ? origin.attr("fill", "white") : origin.attr("fill", "lightgray")
})
\end{lstlisting}

\subsubsection{Predicate Observer}

The predicate observer accepts a predicate and applies a list of transformers depending on the result of the predicate in the current state.

\begin{tabular}{ l l l p{7cm} }
  \textbf{Name} & \textbf{Type} & \textbf{Default} & \textbf{Description} \\
  \hline\noalign{\medskip}
  predicate & string / function* & & The actual predicate that should be evaluated in each state.\\
  \hline\noalign{\medskip}
  cause & string / function* & '\textit{AnimationChanged}' & The trigger cause. Possible values: '\textit{AnimationChanged}', '\textit{ModelChanged}' and '\textit{ModelInitialised}'. \\
  \hline\noalign{\medskip}
  true & list / function** & & A list of transformers (\textit{attr} and \textit{value} pairs) that should be applied on the matched element whenever the defined predicate evaluates to true. Example: 
  [\{attr: "fill", value: "white"\}, \{attr: "stroke", value: "green"\}]\\
  \hline\noalign{\medskip}
  false & list / function** & & A list of transformers (\textit{attr} and \textit{value} pairs) that should be applied on the matched element whenever the defined predicate evaluates to false. Example: 
  [\{attr: "fill", value: "white"\}, \{attr: "stroke", value: "green"\}]\\
  \hline\noalign{\medskip}
  callback & function &  & The callback function is called after each state change.
\end{tabular}

*This attribute also accepts a function that should return its value.

**This attribute also accepts a function that is called based on the result of the defined predicate.

\begin{lstlisting}[float=ht,language=JavaScript]
$("#door").observe("predicate", {
  predicate: "door_open",
  true: [
    {attr: "fill", value: "white"}
  ],
  false: [
    {attr: "fill", value: "lightgray"}
  ]
});
\end{lstlisting}

\subsubsection{Expression Observer}

\subsubsection{Refinement Observer}

The refinements observer observes a list of refinements (model names) and triggers an \textit{enable} function whenever the current model is in the list of refinements or a \textit{disable} function whenever the current model is not in the list of refinements.
The following options can be passed:

\begin{tabular}{ l l l p{7cm} }
  \textbf{Name} & \textbf{Type} & \textbf{Default} & \textbf{Description} \\
  \hline\noalign{\medskip}
  refinements & list / function* & empty list & Define a list of refinements (machine names) that should be observed.\\
  \hline\noalign{\medskip}
  enable & function &  & This function will be called after initialising or changing the model and whenever the current model is included in the list of refinements with its \textit{origin} reference set to the element that the observer is attached to.\\
  \hline\noalign{\medskip}
  disable & function &  & This function will be called after initialising or changing the model and whenever the current model is \textbf{NOT} included in the list of refinements with its \textit{origin} reference set to the element that the observer is attached to.\\
\end{tabular}

*This attribute also accepts a function that should return its value.

\begin{lstlisting}[float=ht!,language=JavaScript]
$("myvisualelement").observe("refinement", {
  refinements: ["Machine01", "Refinement02"],
  enable: function (origin, data) {
    origin.attr("opacity", "1")
  },
  disable: function (origin) {
    origin.attr("opacity", "0.1")
  }
})
\end{lstlisting}

\subsubsection{Remark}

All JavaScript observers can also be created by means of the \textit{prob} API variable. 
This is in particular useful, whenever the user needs to define the selector based on the result of an expression:

\begin{lstlisting}[float=ht!,language=JavaScript]
prob.observe("formula", {
  formulas: ["myvar", "floor", "x>4"],
  trigger: function (data) {
    var el = $("#" + data.values[0].value)
    el.html(data.values[1].value)
    if(data.values[2].value === "TRUE") {
      el.attr("fill","green")
    } else {
      el.attr("fill","red")
    }
  }
});
\end{lstlisting}

\pagebreak

\section{Interactivity}
\label{sec:interactivity}

\subsection{Execute Events}
\label{sec:execute_events}

The execute event handler executes an event after clicking on the matched element.
The user can also define a list of events.
In this case, a tooltip that lists the available events (disabled and enabled) will be shown when hovering the matched element.
The following options can be passed:

\vspace{0.5cm}
\begin{tabular}{ l l l p{7cm} }
  \textbf{Name} & \textbf{Type} & \textbf{Default} & \textbf{Description} \\
  \hline\noalign{\medskip}
  events & list & empty list & Define a list of events with \textit{name} and \textit{predicate} that should be bind with the matched visual elements. \\
  \hline\noalign{\medskip}
  \hspace{0.5cm} name & string / function* & & The name of the event. If the value is a function it takes the return value of the function.\\
  \hline\noalign{\medskip}
  \hspace{0.5cm}  predicate & string / function* & & The predicate that defines the parameters of the event to be executed. If the value is a function it takes the return value of the function.\\
  \hline\noalign{\medskip}
  tooltip & boolean & true & Enable (\textit{true}) or disable (\textit{false}) tooltip when hovering the matched element.\\
  \hline\noalign{\medskip}
  callback & function &  & The callback function is called whenever a bind event was executed.
\end{tabular}

*This attribute also accepts a function that should return its value.

\begin{lstlisting}[float=ht!,language=JavaScript]
$("text[data-some]").executeEvent({
  events: [
    { 
      name: "event1", 
      predicate: function (origin) {
        return "x=" + origin.attr("data-some") 
      }
    },
    {
      name: "event2", 
      predicate: function (origin) {
        return "x=" + origin.attr("data-some")
      }
    } 
  ]
});
\end{lstlisting}

\section{Building a Standalone Visualisation}
\label{sec:build_standalone}

Clone the BMotion Studio for ProB standalone Github repository\footnote{\url{https://github.com/ladenberger/bmotion-prob-standalone}} and put your visualisation into the folder ``resources/workspace''.
In the root folder run the following command, where XXX is the path to the html template file in the ``resources/workspace'' folder (e.g. ``myvis/vis.html''):
\begin{lstlisting}[language=bash]
gradle -Pvisualisation="XXX" buildAll
\end{lstlisting}

If you don't have gradle installed, you can use the gradlew script provided:
\begin{lstlisting}[language=bash]
./gradlew -Pvisualisation="XXX" buildAll
\end{lstlisting}

This should build the binaries without a gradle installation on your computer.
The gradle script will produce a zipped standalone version for all platforms. The zip files are located in the build/distributions folder.


